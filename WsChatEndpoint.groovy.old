package grails.plugin.wschat


import grails.converters.JSON

import javax.servlet.ServletContextEvent
import javax.servlet.ServletContextListener
import javax.servlet.annotation.WebListener
import javax.websocket.DeploymentException
import javax.websocket.OnClose
import javax.websocket.OnError
import javax.websocket.OnMessage
import javax.websocket.OnOpen
import javax.websocket.Session
import javax.websocket.server.ServerContainer
import javax.websocket.server.ServerEndpoint


@WebListener
@ServerEndpoint(value = "/wschat",encoders=MessageEncoder.class, decoders=MessageDecoder.class)
class WsChatEndpoint implements ServletContextListener {
	private static List users = Collections.synchronizedList(new ArrayList());
	static Set<Session> chatroomUsers = Collections.synchronizedSet(new HashSet<Session>())
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
   		final ServerContainer serverContainer =	org.codehaus.groovy.grails.web.context.ServletContextHolder.getServletContext().getAttribute("javax.websocket.server.ServerContainer")
	    try {
            serverContainer.addEndpoint(WsChatEndpoint.class)
        } catch (DeploymentException e) {
            e.printStackTrace()
        }
    }

	@Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
    }
	
    @OnOpen
    public void handleOpen(Session userSession) { 
		chatroomUsers.add(userSession)
    }	
	
    @OnMessage
    public String handleMessage(ChatMessage message,Session userSession) throws IOException {
		verifyAction(userSession,message)
    }
	
    @OnClose
    public void handeClose(Session userSession) {
        chatroomUsers.remove(userSession)
    }
	
    @OnError
    public void handleError(Throwable t) {
        t.printStackTrace()
    }
	
	private void sendUsers() { 
		def myMsg=[:]
		StringBuffer sb=new StringBuffer()
		getCurrentUserNames().each {
			sb.append("${it}\n")
		}
		myMsg.put("users", sb.toString())
		broadcast(myMsg)
	}
	
	private void broadcast(Map msg) {
		def myMsgj=msg as JSON
		Iterator<Session> iterator=chatroomUsers.iterator()
		while (iterator.hasNext()) iterator.next().getBasicRemote().sendText(myMsgj as String)
	}
	private void broadcastMsg(ChatMessage outgoing) {
		Iterator<Session> iterator=chatroomUsers.iterator()
		while (iterator.hasNext()) iterator.next().getBasicRemote().sendObject(outgoing)
	}
	public static List getCurrentUserNames() {
		return Collections.unmodifiableList(users);
	}
	
	private void verifyAction(Session userSession,ChatMessage message) {
		//def myMsg=[:]
		println "------------ ${message}"
		ChatMessage outgoing=new ChatMessage()
		String username=userSession.getUserProperties().get("username") as String
		if (!username) {
			String cusername=message.getMessage()
			userSession.getUserProperties().put("username", cusername)
			users.add(cusername)
			sendUsers()
			ChatMessage welcome=new ChatMessage()
			
			welcome.setName("System")
			welcome.setMessage("${cusername} welcome to chat")
			userSession.getBasicRemote().SendObject(welcome)
			
			
			outgoing.setName(cusername)
			outgoing.setMessage("${cusername} has joined")
			//
			broadcastMsg(outgoing)
			//myMsg.put("message", "${message} has joined")
		}else{
			String cmessage=message.getMessage()
			if (message.startsWith("DISCO:-")) {
				users.remove(username)
				sendUsers()
				//myMsg.put("message", "${username} has left ${message}")
				outgoing.setName(cusername)
				outgoing.setMessage("${cusername} has left")
			}else{
				//myMsg.put("message", "${username}:${message}")
			outgoing.setName(username)
			outgoing.setMessage(cmessage)
			
			}
		}
		//broadcast(myMsg)
		broadcastMsg(outgoing)
	}
	
	private String getCurrentUserName(Session userSession) {
		String username=userSession.getUserProperties().get("username") as String
		if (!username) {
			username="Guest"
			userSession.getUserProperties().put("username", username)
		}
		return username
	}
	
	
}
